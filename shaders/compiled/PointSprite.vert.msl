#include <metal_stdlib>
#include <metal_math>
#include <metal_texture>
using namespace metal;

#line 23 "shaders/src/tone_mapping.slang"
float3 uncharted2ToneMapping_Partial_0(float3 color_0)
{

#line 30
    float3 _S1 = float3(0.15000000596046448)  * color_0;

#line 30
    return (color_0 * (_S1 + float3(0.05000000074505806) ) + float3(0.00400000018998981) ) / (color_0 * (_S1 + float3(0.5) ) + float3(0.06000000238418579) ) - float3(0.06666666269302368) ;
}


float3 uncharted2ToneMapping_0(float3 color_1)
{



    return uncharted2ToneMapping_Partial_0(float3(2.0)  * color_1) * (float3(1.0)  / uncharted2ToneMapping_Partial_0(float3(11.19999980926513672) ));
}


#line 90 "core"
struct main_Result_0
{
    float4 pointColor_0 [[user(_SLANG_ATTR)]];
    float4 position_0 [[position]];
    float pointSize_0 [[point_size]];
};


#line 90
struct vertexInput_0
{
    float3 position_1 [[attribute(0)]];
    float4 color_2 [[attribute(4)]];
};


#line 90
struct _MatrixStorage_float4x4_ColMajornatural_0
{
    array<float4, int(4)> data_0;
};


#line 90
struct TranformBlock_natural_0
{
    _MatrixStorage_float4x4_ColMajornatural_0 model_0;
    _MatrixStorage_float4x4_ColMajornatural_0 viewProj_0;
};


#line 10 "shaders/src/PointSprite.vert.slang"
struct VSOutput_0
{
    float4 pointColor_1;
    float4 position_2;
    float pointSize_1;
};


#line 10
[[vertex]] main_Result_0 main_0(vertexInput_0 _S2 [[stage_in]], TranformBlock_natural_0 constant* transform_0 [[buffer(0)]])
{

#line 18
    thread VSOutput_0 output_0;
    (&output_0)->position_2 = ((((((float4(_S2.position_1, 1.0)) * (matrix<float,int(4),int(4)> (transform_0->model_0.data_0[int(0)][int(0)], transform_0->model_0.data_0[int(1)][int(0)], transform_0->model_0.data_0[int(2)][int(0)], transform_0->model_0.data_0[int(3)][int(0)], transform_0->model_0.data_0[int(0)][int(1)], transform_0->model_0.data_0[int(1)][int(1)], transform_0->model_0.data_0[int(2)][int(1)], transform_0->model_0.data_0[int(3)][int(1)], transform_0->model_0.data_0[int(0)][int(2)], transform_0->model_0.data_0[int(1)][int(2)], transform_0->model_0.data_0[int(2)][int(2)], transform_0->model_0.data_0[int(3)][int(2)], transform_0->model_0.data_0[int(0)][int(3)], transform_0->model_0.data_0[int(1)][int(3)], transform_0->model_0.data_0[int(2)][int(3)], transform_0->model_0.data_0[int(3)][int(3)]))))) * (matrix<float,int(4),int(4)> (transform_0->viewProj_0.data_0[int(0)][int(0)], transform_0->viewProj_0.data_0[int(1)][int(0)], transform_0->viewProj_0.data_0[int(2)][int(0)], transform_0->viewProj_0.data_0[int(3)][int(0)], transform_0->viewProj_0.data_0[int(0)][int(1)], transform_0->viewProj_0.data_0[int(1)][int(1)], transform_0->viewProj_0.data_0[int(2)][int(1)], transform_0->viewProj_0.data_0[int(3)][int(1)], transform_0->viewProj_0.data_0[int(0)][int(2)], transform_0->viewProj_0.data_0[int(1)][int(2)], transform_0->viewProj_0.data_0[int(2)][int(2)], transform_0->viewProj_0.data_0[int(3)][int(2)], transform_0->viewProj_0.data_0[int(0)][int(3)], transform_0->viewProj_0.data_0[int(1)][int(3)], transform_0->viewProj_0.data_0[int(2)][int(3)], transform_0->viewProj_0.data_0[int(3)][int(3)]))));
    (&output_0)->pointSize_1 = 5.0;
    (&output_0)->pointColor_1 = float4(uncharted2ToneMapping_0(_S2.color_2.xyz), 1.0);

#line 21
    thread main_Result_0 _S3;

#line 21
    (&_S3)->pointColor_0 = output_0.pointColor_1;

#line 21
    (&_S3)->position_0 = output_0.position_2;

#line 21
    (&_S3)->pointSize_0 = output_0.pointSize_1;

#line 21
    return _S3;
}
