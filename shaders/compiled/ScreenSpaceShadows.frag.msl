#include <metal_stdlib>
#include <metal_math>
#include <metal_texture>
using namespace metal;

#line 90 "core"
struct _MatrixStorage_float4x4_ColMajornatural_0
{
    array<float4, int(4)> data_0;
};


#line 90
struct ShadowParams_natural_0
{
    _MatrixStorage_float4x4_ColMajornatural_0 projection_0;
    _MatrixStorage_float4x4_ColMajornatural_0 invProjection_0;
    float3 lightDir_0;
    float maxDistance_0;
    int numSteps_0;
};


#line 5176 "core.meta.slang"
struct KernelContext_0
{
    texture2d<float, access::sample> depthTexture_texture_0;
    sampler depthTexture_sampler_0;
    ShadowParams_natural_0 constant* shadow_0;
};


#line 18 "shaders/src/ScreenSpaceShadows.frag.slang"
float3 computeViewPos_0(float3 ndcPos_0, KernelContext_0 thread* kernelContext_0)
{

#line 19
    float4 viewPos_0 = (((float4(ndcPos_0, 1.0)) * (matrix<float,int(4),int(4)> (kernelContext_0->shadow_0->invProjection_0.data_0[int(0)][int(0)], kernelContext_0->shadow_0->invProjection_0.data_0[int(1)][int(0)], kernelContext_0->shadow_0->invProjection_0.data_0[int(2)][int(0)], kernelContext_0->shadow_0->invProjection_0.data_0[int(3)][int(0)], kernelContext_0->shadow_0->invProjection_0.data_0[int(0)][int(1)], kernelContext_0->shadow_0->invProjection_0.data_0[int(1)][int(1)], kernelContext_0->shadow_0->invProjection_0.data_0[int(2)][int(1)], kernelContext_0->shadow_0->invProjection_0.data_0[int(3)][int(1)], kernelContext_0->shadow_0->invProjection_0.data_0[int(0)][int(2)], kernelContext_0->shadow_0->invProjection_0.data_0[int(1)][int(2)], kernelContext_0->shadow_0->invProjection_0.data_0[int(2)][int(2)], kernelContext_0->shadow_0->invProjection_0.data_0[int(3)][int(2)], kernelContext_0->shadow_0->invProjection_0.data_0[int(0)][int(3)], kernelContext_0->shadow_0->invProjection_0.data_0[int(1)][int(3)], kernelContext_0->shadow_0->invProjection_0.data_0[int(2)][int(3)], kernelContext_0->shadow_0->invProjection_0.data_0[int(3)][int(3)]))));
    return viewPos_0.xyz / float3(viewPos_0.w) ;
}


#line 7 "shaders/src/utils.slang"
bool isCoordsInRange_0(float2 uv_0)
{

#line 8
    float _S1 = uv_0.x;

#line 8
    bool _S2;

#line 8
    if(_S1 >= 0.0)
    {

#line 8
        _S2 = (uv_0.y) >= 0.0;

#line 8
    }
    else
    {

#line 8
        _S2 = false;

#line 8
    }

#line 8
    if(_S2)
    {

#line 8
        _S2 = _S1 <= 1.0;

#line 8
    }
    else
    {

#line 8
        _S2 = false;

#line 8
    }
    if(_S2)
    {

#line 9
        _S2 = (uv_0.y) <= 1.0;

#line 9
    }
    else
    {

#line 9
        _S2 = false;

#line 9
    }

#line 8
    return _S2;
}


#line 8
struct pixelOutput_0
{
    float output_0 [[color(0)]];
};


#line 8
struct pixelInput_0
{
    float2 fragUV_0 [[user(_SLANG_ATTR)]];
};


#line 24 "shaders/src/ScreenSpaceShadows.frag.slang"
[[fragment]] pixelOutput_0 main_0(pixelInput_0 _S3 [[stage_in]], texture2d<float, access::sample> depthTexture_texture_1 [[texture(0)]], sampler depthTexture_sampler_1 [[sampler(0)]], ShadowParams_natural_0 constant* shadow_1 [[buffer(0)]])
{

#line 24
    thread KernelContext_0 kernelContext_1;

#line 24
    (&kernelContext_1)->depthTexture_texture_0 = depthTexture_texture_1;

#line 24
    (&kernelContext_1)->depthTexture_sampler_0 = depthTexture_sampler_1;

#line 24
    (&kernelContext_1)->shadow_0 = shadow_1;
    ;

#line 25
    float depth_0 = (((&kernelContext_1)->depthTexture_texture_0).sample(((&kernelContext_1)->depthTexture_sampler_0), (_S3.fragUV_0))).x;

    if(depth_0 >= 1.0)
    {

#line 27
        pixelOutput_0 _S4 = { 1.0 };
        return _S4;
    }

#line 28
    float occlusion_0;

#line 28
    float3 _S5 = computeViewPos_0(float3(_S3.fragUV_0 * float2(2.0)  - float2(1.0) , depth_0), &kernelContext_1);

#line 38
    float3 _S6 = normalize(- (&kernelContext_1)->shadow_0->lightDir_0) * float3((0.05000000074505806 / float((&kernelContext_1)->shadow_0->numSteps_0))) ;

#line 38
    int i_0 = int(0);

#line 38
    float3 rayPos_0 = _S5;

#line 43
    for(;;)
    {

#line 43
        if(i_0 < ((&kernelContext_1)->shadow_0->numSteps_0))
        {
        }
        else
        {

#line 43
            occlusion_0 = 0.0;

#line 43
            break;
        }

#line 44
        float3 rayPos_1 = rayPos_0 + _S6;

        float4 projectedPos_0 = (((float4(rayPos_1, 1.0)) * (matrix<float,int(4),int(4)> ((&kernelContext_1)->shadow_0->projection_0.data_0[int(0)][int(0)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(1)][int(0)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(2)][int(0)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(3)][int(0)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(0)][int(1)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(1)][int(1)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(2)][int(1)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(3)][int(1)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(0)][int(2)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(1)][int(2)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(2)][int(2)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(3)][int(2)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(0)][int(3)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(1)][int(3)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(2)][int(3)], (&kernelContext_1)->shadow_0->projection_0.data_0[int(3)][int(3)]))));
        float3 screenPos_0 = projectedPos_0.xyz / float3(projectedPos_0.w) ;

#line 47
        float2 _S7 = float2(0.5) ;

        float2 rayUV_0 = _S7 + screenPos_0.xy * _S7;
        float rayDepth_0 = screenPos_0.z;
        ;

#line 51
        float sceneDepth_0 = (((&kernelContext_1)->depthTexture_texture_0).sample(((&kernelContext_1)->depthTexture_sampler_0), (rayUV_0))).x;

        if(!isCoordsInRange_0(rayUV_0))
        {

#line 53
            occlusion_0 = 0.0;
            break;
        }

        float depthDelta_0 = rayDepth_0 - sceneDepth_0 - 0.00100000004749745;

#line 57
        bool _S8;

        if(depthDelta_0 >= 0.0)
        {

#line 59
            _S8 = depthDelta_0 < 0.01999999955296516;

#line 59
        }
        else
        {

#line 59
            _S8 = false;

#line 59
        }

#line 59
        if(_S8)
        {

#line 59
            occlusion_0 = 1.0;

            break;
        }

#line 43
        i_0 = i_0 + int(1);

#line 43
        rayPos_0 = rayPos_1;

#line 43
    }

#line 43
    pixelOutput_0 _S9 = { 1.0 - occlusion_0 };

#line 65
    return _S9;
}
