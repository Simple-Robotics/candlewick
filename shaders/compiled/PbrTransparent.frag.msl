#include <metal_stdlib>
#include <metal_math>
#include <metal_texture>
using namespace metal;

#line 27 "shaders/src/pbr_lighting.slang"
float distributionGGX_0(float3 normal_0, float3 H_0, float roughness_0)
{

#line 28
    float a_0 = roughness_0 * roughness_0;
    float a2_0 = a_0 * a_0;
    float _S1 = max(dot(normal_0, H_0), 0.0);


    float denom_0 = _S1 * _S1 * (a2_0 - 1.0) + 1.0;


    return a2_0 / (3.14159274101257324 * denom_0 * denom_0);
}


float geometrySchlickGGX_0(float NdotV_0, float roughness_1)
{

#line 41
    float r_0 = roughness_1 + 1.0;
    float k_0 = r_0 * r_0 / 8.0;
    return NdotV_0 / (NdotV_0 * (1.0 - k_0) + k_0);
}

float geometrySmith_0(float3 normal_1, float3 V_0, float3 L_0, float roughness_2)
{



    return geometrySchlickGGX_0(max(dot(normal_1, L_0), 0.0), roughness_2) * geometrySchlickGGX_0(max(dot(normal_1, V_0), 0.0), roughness_2);
}


#line 22
float3 fresnelSchlick_0(float cosTheta_0, float3 F0_0)
{

#line 23
    return F0_0 + (float3(1.0)  - F0_0) * float3(pow(clamp(1.0 - cosTheta_0, 0.0, 1.0), 5.0)) ;
}


#line 11
struct PbrMaterial_0
{
    float4 baseColor_0;
    float metalness_0;
    float roughness_3;
    float ao_0;
};


#line 56
float3 calculatePbrLighting_0(float3 normal_2, float3 V_1, float3 lightDir_0, const PbrMaterial_0 constant* material_0, float3 lightColor_0, float lightIntensity_0)
{

#line 64
    float3 H_1 = normalize(lightDir_0 + V_1);

    float3 _S2 = material_0->baseColor_0.xyz;



    float3 F_0 = fresnelSchlick_0(max(dot(H_1, V_1), 0.0), mix(float3(0.03999999910593033) , _S2, float3(material_0->metalness_0) ));

    float _S3 = dot(normal_2, lightDir_0);

#line 82
    return ((float3(1.0)  - F_0) * float3((1.0 - material_0->metalness_0))  * _S2 / float3(3.14159274101257324)  + float3((distributionGGX_0(normal_2, H_1, material_0->roughness_3) * geometrySmith_0(normal_2, V_1, lightDir_0, material_0->roughness_3)))  * F_0 / float3((4.0 * max(dot(normal_2, V_1), _S3) + 0.00009999999747379)) ) * (float3(lightIntensity_0)  * lightColor_0) * float3(max(_S3, 0.0)) ;
}


#line 23 "shaders/src/tone_mapping.slang"
float3 uncharted2ToneMapping_Partial_0(float3 color_0)
{

#line 30
    float3 _S4 = float3(0.15000000596046448)  * color_0;

#line 30
    return (color_0 * (_S4 + float3(0.05000000074505806) ) + float3(0.00400000018998981) ) / (color_0 * (_S4 + float3(0.5) ) + float3(0.06000000238418579) ) - float3(0.06666666269302368) ;
}


float3 uncharted2ToneMapping_0(float3 color_1)
{



    return uncharted2ToneMapping_Partial_0(float3(2.0)  * color_1) * (float3(1.0)  / uncharted2ToneMapping_Partial_0(float3(11.19999980926513672) ));
}


#line 10 "shaders/src/PbrTransparent.frag.slang"
struct FSOutput_0
{
    float4 accum_0 [[color(0)]];
    float reveal_0 [[color(1)]];
};


#line 10
struct pixelInput_0
{
    float3 fragViewPos_0 [[user(_SLANG_ATTR)]];
    float3 fragViewNormal_0 [[user(_SLANG_ATTR_1)]];
    float3 fragLightPos_0 [[user(_SLANG_ATTR_2)]];
};


#line 3 "shaders/src/pbr_lighting.slang"
struct LightBlock_0
{
    array<float3, int(4)> direction_0;
    array<float3, int(4)> color_2;
    array<float, int(4)> intensity_0;
    int numLights_0;
    uint useSsao_0;
};


#line 3
struct KernelContext_0
{
    PbrMaterial_0 constant* materialBlock_0;
    LightBlock_0 constant* light_0;
};


#line 16 "shaders/src/PbrTransparent.frag.slang"
[[fragment]] FSOutput_0 main_0(pixelInput_0 _S5 [[stage_in]], float4 fragCoord_0 [[position]], PbrMaterial_0 constant* materialBlock_1 [[buffer(0)]], LightBlock_0 constant* light_1 [[buffer(1)]])
{

    thread KernelContext_0 kernelContext_0;

#line 19
    (&kernelContext_0)->materialBlock_0 = materialBlock_1;

#line 19
    (&kernelContext_0)->light_0 = light_1;
    float3 _S6 = normalize(_S5.fragViewNormal_0);
    float3 _S7 = normalize(- _S5.fragViewPos_0);

    PbrMaterial_0 mat_0 = *materialBlock_1;

    float3 _S8 = float3(int3(int(0)) );

#line 25
    uint i_0 = 0U;

#line 25
    float3 Lo_0 = _S8;
    for(;;)
    {

#line 26
        if(i_0 < uint((&kernelContext_0)->light_0->numLights_0))
        {
        }
        else
        {

#line 26
            break;
        }

#line 26
        float3 _S9 = calculatePbrLighting_0(_S6, _S7, normalize(- (&kernelContext_0)->light_0->direction_0[i_0]), (&kernelContext_0)->materialBlock_0, (&kernelContext_0)->light_0->color_2[i_0], (&kernelContext_0)->light_0->intensity_0[i_0]);

        float3 Lo_1 = Lo_0 + _S9;

#line 26
        i_0 = i_0 + 1U;

#line 26
        Lo_0 = Lo_1;

#line 26
    }

#line 38
    float alpha_0 = mat_0.baseColor_0.w;


    float weight_0 = clamp((alpha_0 * 10.0 + 0.00999999977648258) * (1.0 - fragCoord_0.z * 0.30000001192092896), 0.00999999977648258, 1000.0);

    thread FSOutput_0 output_0;
    (&output_0)->accum_0 = float4(pow(uncharted2ToneMapping_0(float3(0.02999999932944775)  * mat_0.baseColor_0.xyz * float3(mat_0.ao_0)  + Lo_0), float3(0.45454543828964233) ) * float3(alpha_0)  * float3(weight_0) , alpha_0 * weight_0);
    (&output_0)->reveal_0 = alpha_0;
    return output_0;
}
